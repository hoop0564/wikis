# TCP/IP

Transimission Control Protocol，传输控制协议。

- 要解决的问题：

  > 是为了在不可靠的互联网络上提供可靠的端到端字节流而专门设计的一个传输协议。因为互联网络的不同部分可能有截然不同的拓扑结构、带宽、延迟、数据包大小和其他参数。TCP的设计目标是能够动态地适应互联网络的这些特性，而且具备面对各种故障时的健壮性。

- 关键步骤：

  > 应用层向TCP层发送用于网间传输的、用8位字节表示的数据流，然后TCP把数据流分区成适当长度的报文段（通常受该计算机连接的网络的数据链路层的最大传输单元（MTU）的限制）。之后TCP把结果包传给IP层，由它来通过网络将包传送给接收端实体的TCP层。TCP为了保证不发生丢包，就给每个包一个序号，同时序号也保证了传送到接收端实体的包的按序接收。然后接收端实体对已成功收到的包发回一个相应的确认（ACK）；如果发送端实体在合理的往返时延（[RTT](https://baike.baidu.com/item/RTT)）内未收到确认，那么对应的数据包就被假设为已丢失将会被进行重传。TCP用一个校验和函数来检验数据是否有错误；在发送和接收时都要计算校验和。 [3] 

- TCP职责：

  > IP层并不保证数据报一定被正确地递交到接收方，也不指示数据报的发送速度有多快。正是TCP负责既要足够快地发送数据报，以便使用网络容量，但又不能引起网络拥塞：而且，TCP超时后，要重传没有递交的数据报。即使被正确递交的数据报，也可能存在错序的问题，这也是TCP的责任，它必须把接收到的数据报重新装配成正确的顺序。简而言之，TCP必须提供可靠性的良好性能，这正是大多数用户所期望的而IP又没有提供的功能。 [2] 



## 名词解释

### TCP拥塞控制算法-AIMD算法

1. 慢启动

   > 每当建立一个TCP连接时或一个TCP连接发生超时重传后，该连接便进入慢启动阶段。进入慢启动后，TCP实体将拥塞窗口的大小初始化为一个报文段，即：cwnd=1。此后，每收到一个报文段的确认（ACK），cwnd值加1，即拥塞窗口按指数增加。
   >
   > - 当cwnd值超过慢启动阐值（ssthresh）时，慢启动阶段结束，进入拥塞避免阶段
   >
   > - 当发生报文段丢失重传时，慢启动阶段结束，重新进入慢启动阶段。

2. 拥塞避免

   > 在慢启阶段，当cwnd值超过慢启动阐值（ssthresh）后，慢启动过程结束，TCP连接进入拥塞避免阶段。在拥塞避免阶段，每一次发送的cwnd个报文段被完全确认后，才将cwnd值加1。在此阶段，cwnd值线性增加。

3. 快速重传

   > 快速重传是对超时重传的改进。当源端收到对同一个报文的三个重复确认时，就确定一个报文段已经丢失，因此立刻重传丢失的报文段，而不必等到重传定时器（RTO）超时。以此减少不必要的等待时间。

4. 快速恢复

   > 快速恢复是对丢失恢复机制的改进，即从故障中快速恢复到正常传输状态。在快速重传之后，不经过慢启动过程而直接进入拥塞避免阶段。每当快速重传后，置ssthresh=cwnd/2、ewnd=ssthresh+3。此后，每收到一个重复确认，将cwnd值加1，直至收到对丢失报文段和其后若干报文段的累积确认后，置cwnd=ssthresh，进入拥塞避免阶段。



### TCP规定

1. 数据分片：发送端对用户数据进行分片，接收端进行重组，由TCP决定分片的大小并控制分片和重组
2. 到达确认
3. 超时重发
4. 滑动窗口：TCP连接的每一方的接受缓冲区空间大小都固定，接收端只允许另一端发送接收端缓冲区所能接纳的数据，TCP在滑动窗口的基础上提供了流量控制，防止较快主机致使较慢主机的缓冲区溢出；
5. 失序处理：作为IP数据报来传输的TCP分片到达时可能会失序，TCP将对收到的数据进行重新排序，将收到的数据以正确的顺序交给应用层。
6. 重复处理：TCP的接收端负责把IP数据报传输的可能重复的数据进行丢弃。
7. 数据校验



### TCP首部格式

![img](../images/TCP-protocol.png)



| 英文名                 | 含义                                                         | 位数 | 说明 |
| ---------------------- | ------------------------------------------------------------ | ---- | ---- |
| Source Port            | 源端口                                                       | 16位 | -    |
| Destination Port       | 目的端口                                                     | 16位 | -    |
| Sequence Number        | 发送数据包中的序列号                                         | 32位 |      |
| Acknowledgement Number | 确认序列号                                                   | 32位 |      |
| Data Offset            | 数据偏移，其值是TCP首部长度除以4                             | 4位  |      |
| Flag                   | 先下表                                                       | -    |      |
| Checksum               | 校验和                                                       | 16位 |      |
| Urgent Pointers        | 紧急指针，表示紧急数据相对序列号（Sequence Number字段的值）的偏移 |      |      |

标志位（Reserved右边的）：

| 简写 | 全称                                              |
| ---- | ------------------------------------------------- |
| URG  | 表示Urgent Pointer字段有意义                      |
| ACK  | 表示Acknowledge Number 字段有意义                 |
| PSH  | 表示Push功能                                      |
| RST  | 表示复位TCP连接                                   |
| SYN  | 表示SYN报文（在建立TCP连接的时候使用）            |
| FIN  | 表示没有数据需要发送了（在关闭TCP连接的时候使用） |



### RTT

Round Trip Time，网络往返时间，有三部分组成：

1. 链路的传播时间（propagation delay)
2. 末端系统的处理时间
3. 路由器缓存中的排队和处理时间（queuing delay）

其中，前两个部分的值对于一个TCP连接是相对固定的，后一个会随着整个网络拥塞程度的变化而变化。所以RTT的变化在一定程度上反映了网络的拥塞程度。



## 

### RTO

Retransmission TimeOut，重传超时时间。

TCP超时与重传中一个很重要的部分是对一个给定链接的RTT的测量。由于网络流量的变化，这个时间会相应地发生改变，TCP需要跟踪这些变化并动态调整超时时间RTO。



### MSL

Max Survive Live 最大报文段生存时间





## LFN长肥网络

带宽延迟积很大的网络叫做长肥网络。在LFN中建立的TCP链接叫做长肥管道。一个链接的时延带宽积可表示为：

```
capaticy(b) = bandwidth(b/s)xround-triptime(s)
```

具有打的带宽时延积的网络被称为长肥网络。其中存在很多问题：

1. TCP的窗口大小为16bit，即65535字节。这就将发送方发送但未被确认的数据的总长度限制到了65535字节。对于LFN管道，这可能会出现所有的数据还未到达接收方，但是发送方已受限于窗口大小而不能继续发送的情形。这就极大的降低了网络的吞吐量。

   >  扩大窗口选项可以解决这个问题

2. 根据TCP的拥塞控制，丢失分组会导致链接进行拥塞控制，即便是由于冗余ACK而进入了快速恢复，也会使得拥塞窗口降低一半，而如果是由于超时进入了慢启动，这回导致网络吞吐量降低。

   > 选择确认（SACK）可以用来部分避免该问题，采用该技术使得接收方可以有选择的对无序到达的报文段进行确认，而不是采用累积确认，这样被确认的报文段就不会超时，也不会有冗余的ACK。

3. 在LFN中，需要高的RTT测量机制。

4. TCP对每个字节数据使用一个32bit无符号的序号来进行标识。TCP定义了MSL，在LFN中，由于序号空间有限，在已经传输了4294967296个字节以后序号会被重用。如果网络快到在不到一个MSL的时候序号就发生了回绕，网络中就会有两个相同序号的不同的报文段，接收方将无法区分它们的顺序。（在一个千网络中只需要34秒就可以完成4294967296个字节的发送）。

   > 使用TCP的时间戳选项的PAWS(ProtectionAgainstWrappedSequencenumbers)算法（**保护回绕的序号**）可以解决该问题。



## Little-End小端 和 Big-End大端

描述的是两种不同的字节在内存中的存储顺序

```c
short int a = 0xABCD;
// 小端存储：0xCD, 0xAB
// 大端存储：0xAB, 0xCD
```

即：大端和书写顺序一致！

- 操作系统（主机）采用小端
- 网络通信都是大端
- socket 编程中的 htons()和htonl()

```c
inet->inet_sport = htons(inet->inet_num); // 绑定端口
```

htons = host to network short

htonl = host to network long

反之：ntohl(), ntohs()

<img src="../images/bigEnd-littleEnd.png" alt="image-20210322213828135" style="zoom: 67%;" />



## 参考资料

- [TCP中RTT的测量和RTO的计算](https://blog.csdn.net/zhangskd/article/details/7196707)

- [长肥管道](https://baike.baidu.com/item/%E9%95%BF%E8%82%A5%E7%AE%A1%E9%81%93/10679040?fr=aladdin)

- [TCP百科](https://baike.baidu.com/item/TCP/33012?fr=aladdin)