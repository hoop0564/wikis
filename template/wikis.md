# wikis



## c++11的std::move设计意图

- [左值、左值引用、右值、右值引用](http://www.cnblogs.com/SZxiaochun/p/8017475.html%EF%BC%89) 

- 右值引用有一个重要的性质—只能绑定到一个将要销毁的对象，为了支持移动操作

- 移动构造函数

- [是为性能而生](https://www.cnblogs.com/yoyo-sincerely/p/8658075.html)

- 是将对象的状态或者所有权从一个对象注意到另一个对象，只是注意，没有内存的搬迁或者内存拷贝

- 拷贝构造需要深拷贝，移动构造不需要

- 从库使用者来说，解决了临时对象效率问题，没有拷贝构造和拷贝复制的性能损耗

  ```
  如string类在赋值或者拷贝构造函数中会声明char数组来存放数据，然后把原string中的 char 数组被析构函数释放，如果a是一个临时变量，则上面的拷贝，析构就是多余的，完全可以把临时变量a中的数据直接 “转移” 到新的变量下面即可。
  ```

- 它将一个左值强制转化为右值引用，继而可以通过右值引用使用该值，以用于移动语义。

- 赋值操作符也可以是移动赋值。

- reference:

  1. [std::move作用详解](https://blog.csdn.net/qq_30683329/article/details/88532673)

  

## c++98里的拷贝构造函数什么情况下会报错

- 如果类中没有显示定义拷贝构造函数，编译器会给类默认生成一个

- 如果类中有指针变量，且有动态内存分配，则必须有一个拷贝构造函数！

- 拷贝构造函数的最常见形式如下：

  ```c++
  classname (const classname &obj) {   
      // 构造函数的主体 
  }
  ```



## lib/dll

- 静态库的*.lib
  - 如果文件名是lib*.lib，则是静态链接的静态库，编译时会都编译进去，运行时无需dll
  - 如果文件名是*.lib，则是动态链接的静态库，编译时不会都编译进去，运行时需要dll
- 项目导入库时，用pragma的先后顺序



## hpp头文件

实质就是.cpp的实现代码混入.h头文件中，定义和实现都包含在同一文件。

- header plus plus的简写
- xx.cpp可以include此hpp，hpp会一起直接编译到xx.obj中，不再生成单独的obj，也不用加入到project这样中进行编译
- 如果被多个cpp引用，hpp中就不可定义全局变量和全局静态变量，否则会有符号重定义错误，可封装为类的静态方法
- 类之间不可循环调用，可用前向引用声明解决
- 采用hpp将大幅减少调用project的cpp文件数和编译次数，适合做公共的开源库
