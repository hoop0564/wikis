# Redis



## 用作锁

**悲观锁**

- 很悲观，认为什么时候都会出问题，无论做什么都会加锁！

**乐观锁**

- 很乐观，认为什么时候大都不会出问题，所以不会上锁！更新数据的时候去判断一下，在此期间是否有人修改过这个数据
- 先获取version，类似MySQL
- 更新的时候比较version

> 监控！用Watch



## 主从复制

### 作用

1. 数据冗余
2. 读写分离，通常配置为一主二从
3. 故障恢复
4. 负载均衡
5. 高可用基石



## 有序集合zset

成绩的有序排序



## 漏斗限流模块：Redis-Cell

Redis 4.0提供了一个限流Redis-Cell模块。该模块也使用了漏斗算法，并提供了原子的限流指令。

```bash
# 限制用户每60秒最多回复30次（漏水速率），漏斗初始容量为15
> cl.throttle user1:reply 15 30 60

# 操作回传值：
1) (interger) 0		# 0表示允许 1表示拒绝
1) (interger) 15	# 漏斗容量 capacity
1) (interger) 14	# 漏斗剩余空间 left_quota
1) (interger) -1	# 如果被拒绝了，需要多长时间后再试，单位秒
1) (interger) 2		# 多长时间后，漏斗完全空出来，单位秒（left_quota==capacity)
```

漏斗初始容量：是指一开始可以连续回复15个帖子，然后才开始受漏斗速率的影响！

返回值有重试时间，业务可以做sleep或异步定时任务来重试。



## 分布式锁

1. `setnx`: set if not exists

   1. 如果不存在就占坑，后面用del释放，缺点是如果这个进程宕机了或多线程情况，会有死锁或释放了不是自己的锁

   ```bash
   setnx key value
   ...logic
   del key
   ```

   2. 占坑后加入一个超时设置，自动释放，缺点是redis-server宕机了，expire也得不到执行，造成死锁

   ```
   setnx key value
   expire key 5
   del key
   ```

2. `set key value ex 5 nx`

3. Redis的分布式锁，不能解决超时问题，如果在加锁和释放锁之间的逻辑执行的太久，以至于超出了锁的超时限制，就会在多线程/多进程的环境中出现问题，这时需要人工介入。

   > 稍微安全的方法是：set的value对应一个随机数，释放时先匹配下随机数是否一致，再删除key！因为del时不再是原子操作，这就需要lua脚本来处理了。lua脚本可以保证连续多个指令的原子性执行。



## zset内部

内部实现是一个**hash字典**加一个**跳跃列表（skiplist）**

- redis的跳表共有64层，可容纳2的64方个元素

- kv之间使用指针串起来形成**双向链表结构**！且是有序排列的，从小到大

- 不同的kv层高，层高越高的kv越少。每一层元素的遍历都是从kv header出发。

- 跳表有了多层结构之后，查找定位的算法复杂度是**O(logN)**。从最高层开始逐层找比”我“小的元素

  

### 插入过程

新插入的节点到底有多少层，使用的是**随机算法**。

在搜索合适插入点的过程中将”**搜索路径**“找出来，然后就可以开始创建新节点。创建的时候需要给这个节点随机分配一个层数，再将搜索路径上的节点和这个新节点通过前向后向指针串起来。如果分配的新节点的高度高于当前跳跃列表的最大高度，就需要更新一下跳跃列表的最大高度。

### 删除过程

需要先把”搜索路径“找出来，然后对于每层的相关节点**重排一下前向后向指针**，同时注意更新最高层数maxLevel

### 更新过程

redis遇到score值改变了的情况就**直接删除后再插入**，需要经过两次路径搜索，不会去判断位置是否需要调整。所有zadd的代码似乎还有优化空间。

### 如何算出rank

skiplist的forward指针上进行了优化，给每一个forward指针都增加了span属性，表示从前一个节点沿着当前层的forward指针跳到当前这个节点，中间会跳过多少个节点。redis在插入、删除操作时会小心翼翼地更新span值得大小。

这样当我们要计算一个元素的排名时，只需要**将”搜索路径“经过的所有节点的跨度span值进行叠加**，就可以算出元素的最终rank值。