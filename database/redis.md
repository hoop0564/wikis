# Redis



## 用作锁

**悲观锁**

- 很悲观，认为什么时候都会出问题，无论做什么都会加锁！

**乐观锁**

- 很乐观，认为什么时候大都不会出问题，所以不会上锁！更新数据的时候去判断一下，在此期间是否有人修改过这个数据
- 先获取version，类似MySQL
- 更新的时候比较version

> 监控！用Watch



## 主从复制

### 作用

1. 数据冗余
2. 读写分离，通常配置为一主二从
3. 故障恢复
4. 负载均衡
5. 高可用基石



## 有序集合zset

成绩的有序排序



## 漏斗限流模块：Redis-Cell

Redis 4.0提供了一个限流Redis-Cell模块。该模块也使用了漏斗算法，并提供了原子的限流指令。

```bash
# 限制用户每60秒最多回复30次（漏水速率），漏斗初始容量为15
> cl.throttle user1:reply 15 30 60

# 操作回传值：
1) (interger) 0		# 0表示允许 1表示拒绝
1) (interger) 15	# 漏斗容量 capacity
1) (interger) 14	# 漏斗剩余空间 left_quota
1) (interger) -1	# 如果被拒绝了，需要多长时间后再试，单位秒
1) (interger) 2		# 多长时间后，漏斗完全空出来，单位秒（left_quota==capacity)
```

漏斗初始容量：是指一开始可以连续回复15个帖子，然后才开始受漏斗速率的影响！

返回值有重试时间，业务可以做sleep或异步定时任务来重试。



## 分布式锁

1. `setnx`: set if not exists

   1. 如果不存在就占坑，后面用del释放，缺点是如果这个进程宕机了或多线程情况，会有死锁或释放了不是自己的锁

   ```bash
   setnx key value
   ...logic
   del key
   ```

   2. 占坑后加入一个超时设置，自动释放，缺点是redis-server宕机了，expire也得不到执行，造成死锁

   ```
   setnx key value
   expire key 5
   del key
   ```

2. `set key value ex 5 nx`

3. Redis的分布式锁，不能解决超时问题，如果在加锁和释放锁之间的逻辑执行的太久，以至于超出了锁的超时限制，就会在多线程/多进程的环境中出现问题，这时需要人工介入。

   > 稍微安全的方法是：set的value对应一个随机数，释放时先匹配下随机数是否一致，再删除key！因为del时不再是原子操作，这就需要lua脚本来处理了。lua脚本可以保证连续多个指令的原子性执行。



## zset内部

zset的内部实现是**一个hash字典加一个跳跃列表（skiplist）**

- redis的跳表共有64层，可容纳2的64方个元素
- kv之间使用指针串起来形成双向链表结构！且是有序排列的，从小到大
- 不同的kv层高，层高越高的kv越少。每一层元素的遍历都是从kv header出发。
- 跳表有了多层结构之后，查找定位的算法复杂度是O(logN)。从最高层开始逐层找比”我“小的元素
- 插入节点使用的是随机层数