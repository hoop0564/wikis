# C++11

讨论了有了哪些新特性，和为什么有这些新特性！



## Lambda 表达式

Lambda表达式来源于函数式编程，说白就了就是在使用的地方定义函数，有的语言叫“闭包”。

```c++
int main()
{
   char s[]="Hello World!";
   int Uppercase = 0; //modified by the lambda
   for_each(s, s+sizeof(s), [&Uppercase] (char c) {
    if (isupper(c))
     Uppercase++;
    });
 	 cout << Uppercase << " uppercase letters in: " << s <<endl;
}
```

在传统的STL中for_each() 这个玩意最后那个参数需要一个“函数对象”，所谓函数对象，其实是一个class，这个class重载了`operator()`，于是这个对象可以像函数的式样的使用。实现一个函数对象并不容易，需要使用template，比如下面这个例子就是函数对象的简单例子（实际的实现远比这个复杂）：

```c++
template <class T>
class less
{
public:
  bool operator()(const T&l, const T&r)const
  {
    return l < r;
  }
};
```

所以，**C++引入Lambda的最主要原因就是**

**1）可以定义匿名函数，**

**2）编译器会把其转成函数对象**。



## 自动化推导 decltype

关于 `decltype` 是一个操作符，其可以评估括号内表达式的类型，其规则如下：

1. 如果表达式e是一个变量，那么就是这个变量的类型。
2. 如果表达式e是一个函数，那么就是这个函数返回值的类型。
3. 如果不符合1和2，如果e是左值，类型为T，那么decltype(e)是T&；如果是右值，则是T。

原文给出的示例如下，我们可以看到，这个让的确我们的定义变量省了很多事。

```c++
const vector<int> vi;
typedef decltype (vi.begin()) CIT;
CIT another_const_iterator;
```

还有一个适合的用法是用来`typedef`函数指针，也会省很多事。比如：

```c++
decltype(&myfunc) pfunc = 0;
typedef decltype(&A::func1) type;
```



## 右值引用

因为`string`类中保存了一个动态内存分存的`char`*指针，如果一个`string`对象发生**拷贝赋值**（如：函数返回），`string`类里的`char`*内存只能通过创建一个新的临时对象，并把函数内的对象的内存copy到这个新的对象中，然后销毁临时对象及其内存。**这是原来C++性能上重点被批评的事**。

能通过右值引用，string的构造函数需要改成“move构造函数”，如下所示。这样一来，使得对某个string的右值引用可以单纯地从右值复制其内部C-style的指针到新的string，然后留下空的右值。这个操作不需要内存数组的复制，而且空的暂时对象的析构也不会释放内存。其更有效率。

```c++
class string
{
	string (string&&); //move constructor
  string&& **operator**=(string&&); //move assignment operator
};
```

The C++11 STL中广泛地使用了右值引用和move语议。因此，很多算法和容器的性能都被优化了。

## 

## 参考资料

- [C++11 中值得关注的几大变化（详解）](https://coolshell.cn/articles/5265.html)

